"""DuckDB data store for Bronze layer persistence.

This module provides the DuckDBStore class for high-throughput batch inserts
of raw Hacker News data into the Bronze layer. All operations are wrapped
in transactions to ensure atomicity.
"""

import json
from datetime import datetime, timezone
from types import TracebackType
from typing import Optional
from uuid import UUID

import duckdb
import structlog

from techpulse.storage.exceptions import InvalidPayloadError, TransactionError
from techpulse.storage.manager import DuckDBManager
from techpulse.storage.schema import RAW_HN_ITEMS_TABLE

logger = structlog.get_logger(__name__)


class DuckDBStore:
    """High-throughput data store for Bronze layer persistence.

    This class handles batch inserts of raw dictionaries into the raw_hn_items
    table. It composes DuckDBManager internally for connection management and
    wraps all inserts in transactions to ensure atomicity.

    The store generates UTC timestamps for the ingested_at column, ensuring
    consistent server-side timestamping regardless of caller timezone.

    Attributes:
        manager: The underlying DuckDBManager instance.

    Example:
        >>> from uuid import uuid4
        >>> store = DuckDBStore()
        >>> with store:
        ...     items = [{"id": 123, "type": "story"}]
        ...     count = store.insert_items(uuid4(), items)
        ...     print(f"Inserted {count} items")
    """

    def __init__(self, database_path: Optional[str] = None) -> None:
        """Initialize the DuckDB store.

        Args:
            database_path: Optional explicit path to the database file.
                          Passed through to DuckDBManager.
        """
        self._manager = DuckDBManager(database_path=database_path)
        self._log = logger.bind(component="DuckDBStore")

    @property
    def manager(self) -> DuckDBManager:
        """Return the underlying DuckDBManager instance.

        Returns:
            DuckDBManager: The manager handling database connections.
        """
        return self._manager

    def __enter__(self) -> "DuckDBStore":
        """Enter the context manager and establish database connection.

        Returns:
            DuckDBStore: The store instance with an active database connection.

        Raises:
            StorageConnectionError: If the connection cannot be established.
        """
        self._manager.__enter__()
        self._log.debug("store_opened")
        return self

    def __exit__(
        self,
        exc_type: Optional[type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> None:
        """Exit the context manager and close the database connection.

        Args:
            exc_type: Exception type if an exception was raised.
            exc_val: Exception value if an exception was raised.
            exc_tb: Exception traceback if an exception was raised.
        """
        self._manager.__exit__(exc_type, exc_val, exc_tb)
        self._log.debug("store_closed")

    def _get_connection(self) -> duckdb.DuckDBPyConnection:
        """Return the active database connection.

        Returns:
            duckdb.DuckDBPyConnection: The active database connection.

        Raises:
            RuntimeError: If called outside of a context manager.
        """
        return self._manager.get_connection()

    def _generate_utc_timestamp(self) -> datetime:
        """Generate a UTC timestamp for the current moment.

        Returns:
            datetime: The current UTC timestamp with timezone info.
        """
        return datetime.now(timezone.utc)

    def _validate_and_serialize_payload(
        self, item: dict[str, object], index: int
    ) -> str:
        """Validate and serialize a dictionary to JSON string.

        Args:
            item: The dictionary to serialize.
            index: The index of the item in the batch (for error reporting).

        Returns:
            str: The JSON-serialized string.

        Raises:
            InvalidPayloadError: If the item cannot be serialized to JSON.
        """
        try:
            return json.dumps(item, separators=(",", ":"))
        except (TypeError, ValueError) as error:
            raise InvalidPayloadError(
                payload_index=index,
                reason=f"Failed to serialize to JSON: {error}",
            ) from error

    def insert_items(self, load_id: UUID, items: list[dict[str, object]]) -> int:
        """Insert a batch of raw dictionaries into the Bronze layer.

        All items are inserted within a single transaction. If any item
        fails validation, the entire batch is rolled back.

        The ingested_at timestamp is generated by this method (UTC),
        ensuring consistent server-side timestamping.

        Args:
            load_id: The unique identifier for this ingestion batch.
            items: List of raw dictionaries to insert as JSON payloads.

        Returns:
            int: The number of rows successfully inserted.

        Raises:
            InvalidPayloadError: If any item fails JSON serialization.
            TransactionError: If the transaction fails to commit.
            RuntimeError: If called outside of a context manager.
        """
        if not items:
            self._log.debug("insert_items_empty_batch", load_id=str(load_id))
            return 0

        connection = self._get_connection()
        ingested_at = self._generate_utc_timestamp()

        self._log.debug(
            "insert_items_start",
            load_id=str(load_id),
            item_count=len(items),
        )

        serialized_payloads: list[str] = []
        for index, item in enumerate(items):
            serialized_payloads.append(
                self._validate_and_serialize_payload(item, index)
            )

        try:
            connection.execute("BEGIN TRANSACTION")

            insert_sql = f"""
                INSERT INTO {RAW_HN_ITEMS_TABLE} (load_id, ingested_at, payload)
                VALUES (?, ?, ?::JSON)
            """

            for payload in serialized_payloads:
                connection.execute(insert_sql, [str(load_id), ingested_at, payload])

            connection.execute("COMMIT")

            self._log.debug(
                "insert_items_success",
                load_id=str(load_id),
                inserted_count=len(items),
            )

            return len(items)

        except InvalidPayloadError:
            connection.execute("ROLLBACK")
            raise

        except duckdb.Error as error:
            try:
                connection.execute("ROLLBACK")
            except duckdb.Error:
                pass

            error_message = str(error).lower()
            if "json" in error_message or "parse" in error_message:
                raise InvalidPayloadError(
                    payload_index=-1,
                    reason=f"Database rejected JSON payload: {error}",
                ) from error

            raise TransactionError(
                operation="insert",
                reason=str(error),
            ) from error

        except Exception as error:
            try:
                connection.execute("ROLLBACK")
            except duckdb.Error:
                pass

            raise TransactionError(
                operation="insert",
                reason=str(error),
            ) from error

    def get_item_count(self) -> int:
        """Return the total number of items in the raw_hn_items table.

        Returns:
            int: The total row count.

        Raises:
            RuntimeError: If called outside of a context manager.
        """
        connection = self._get_connection()
        result = connection.execute(
            f"SELECT COUNT(*) FROM {RAW_HN_ITEMS_TABLE}"
        ).fetchone()

        if result is None:
            return 0

        return int(result[0])
