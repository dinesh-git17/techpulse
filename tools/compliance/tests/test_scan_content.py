# pylint: disable=import-error,wrong-import-position,import-outside-toplevel,missing-function-docstring
"""
Unit tests for scan_content.py
"""

from __future__ import annotations

import sys
import tempfile
import unittest
from io import StringIO
from pathlib import Path
from unittest.mock import patch

sys.path.insert(0, str(Path(__file__).parent.parent))

from scan_content import (
    Config,
    DenylistRule,
    Violation,
    format_violation,
    load_config,
    normalize_text,
    scan_file,
    scan_line,
    should_scan_file,
    walk_directory,
)


class TestNormalizeText(unittest.TestCase):
    """Tests for NFKC normalization and lowercasing."""

    def test_lowercase_conversion(self) -> None:
        self.assertEqual(normalize_text("ChatGPT"), "chatgpt")

    def test_mixed_case(self) -> None:
        self.assertEqual(normalize_text("OpenAI"), "openai")

    def test_unicode_normalization(self) -> None:
        # NFKC normalizes fullwidth characters
        fullwidth_a = "\uff21"  # Fullwidth A
        self.assertEqual(normalize_text(fullwidth_a), "a")

    def test_already_lowercase(self) -> None:
        self.assertEqual(normalize_text("already lower"), "already lower")


class TestDenylistRule(unittest.TestCase):
    """Tests for DenylistRule class."""

    def test_basic_pattern(self) -> None:
        rule = DenylistRule(r"\bchatgpt\b", "Test rule")
        self.assertIsNotNone(rule.regex.search("chatgpt"))
        self.assertIsNone(rule.regex.search("notchatgpthere"))

    def test_case_insensitive(self) -> None:
        rule = DenylistRule(r"\bchatgpt\b", "Test rule")
        self.assertIsNotNone(rule.regex.search("ChatGPT"))
        self.assertIsNotNone(rule.regex.search("CHATGPT"))

    def test_exceptions_default(self) -> None:
        rule = DenylistRule(r"\btest\b", "Test rule")
        self.assertEqual(rule.exceptions, [])

    def test_exceptions_provided(self) -> None:
        rule = DenylistRule(r"\btest\b", "Test rule", ["allowed.py"])
        self.assertEqual(rule.exceptions, ["allowed.py"])


class TestScanLine(unittest.TestCase):
    """Tests for line scanning functionality."""

    def setUp(self) -> None:
        self.rules = [
            DenylistRule(r"\bchatgpt\b", "ChatGPT reference"),
            DenylistRule(r"\bopenai\b", "OpenAI reference"),
        ]

    def test_detects_violation(self) -> None:
        violations = scan_line(
            "Generated by ChatGPT",
            1,
            "test.py",
            "test.py",
            self.rules,
        )
        self.assertEqual(len(violations), 1)
        self.assertEqual(violations[0].match_text.lower(), "chatgpt")

    def test_no_violation_clean_line(self) -> None:
        violations = scan_line(
            "This is a clean line",
            1,
            "test.py",
            "test.py",
            self.rules,
        )
        self.assertEqual(len(violations), 0)

    def test_multiple_violations_per_line(self) -> None:
        violations = scan_line(
            "ChatGPT and OpenAI are both mentioned",
            1,
            "test.py",
            "test.py",
            self.rules,
        )
        self.assertEqual(len(violations), 2)

    def test_exception_skips_file(self) -> None:
        rules_with_exception = [
            DenylistRule(r"\bchatgpt\b", "ChatGPT reference", ["allowed.py"]),
        ]
        violations = scan_line(
            "Generated by ChatGPT",
            1,
            "allowed.py",
            "allowed.py",
            rules_with_exception,
        )
        self.assertEqual(len(violations), 0)

    def test_word_boundary_prevents_false_positive(self) -> None:
        rules = [DenylistRule(r"\bgpt\b", "GPT reference")]
        violations = scan_line(
            "from cryptography import cipher",
            1,
            "test.py",
            "test.py",
            rules,
        )
        self.assertEqual(len(violations), 0)


class TestShouldScanFile(unittest.TestCase):
    """Tests for file extension filtering."""

    def test_python_file_included(self) -> None:
        extensions = {".py", ".js", ".ts"}
        self.assertTrue(should_scan_file(Path("test.py"), extensions))

    def test_binary_file_excluded(self) -> None:
        extensions = {".py", ".js", ".ts"}
        self.assertFalse(should_scan_file(Path("image.png"), extensions))

    def test_no_extension_excluded(self) -> None:
        extensions = {".py", ".js", ".ts"}
        self.assertFalse(should_scan_file(Path("Makefile"), extensions))


class TestScanFile(unittest.TestCase):
    """Tests for file scanning."""

    def setUp(self) -> None:
        self.rules = [DenylistRule(r"\bchatgpt\b", "ChatGPT reference")]

    def test_scan_file_with_violations(self) -> None:
        with tempfile.NamedTemporaryFile(
            mode="w",
            suffix=".py",
            delete=False,
            encoding="utf-8",
        ) as f:
            f.write("# Generated by ChatGPT\n")
            f.write("print('hello')\n")
            temp_path = Path(f.name)

        try:
            violations = scan_file(temp_path, "test.py", self.rules)
            self.assertEqual(len(violations), 1)
            self.assertEqual(violations[0].line_number, 1)
        finally:
            temp_path.unlink()

    def test_scan_clean_file(self) -> None:
        with tempfile.NamedTemporaryFile(
            mode="w",
            suffix=".py",
            delete=False,
            encoding="utf-8",
        ) as f:
            f.write("# Clean code\n")
            f.write("print('hello')\n")
            temp_path = Path(f.name)

        try:
            violations = scan_file(temp_path, "test.py", self.rules)
            self.assertEqual(len(violations), 0)
        finally:
            temp_path.unlink()

    def test_encoding_error_skips_file(self) -> None:
        with tempfile.NamedTemporaryFile(
            mode="wb",
            suffix=".py",
            delete=False,
        ) as f:
            f.write(b"\xff\xfe invalid utf-8 \x80\x81")
            temp_path = Path(f.name)

        try:
            stderr_capture = StringIO()
            with patch("sys.stderr", stderr_capture):
                violations = scan_file(temp_path, "test.py", self.rules)
            self.assertEqual(len(violations), 0)
            self.assertIn("WARNING", stderr_capture.getvalue())
            self.assertIn("encoding error", stderr_capture.getvalue())
        finally:
            temp_path.unlink()


class TestWalkDirectory(unittest.TestCase):
    """Tests for directory traversal."""

    def setUp(self) -> None:
        self.temp_dir = tempfile.mkdtemp()
        self.config = Config(
            denylist=[DenylistRule(r"\bchatgpt\b", "ChatGPT reference")],
            extensions_to_scan={".py"},
            ignore_dirs={"node_modules", "__pycache__"},
            allowlist_files=set(),
        )

    def tearDown(self) -> None:
        import shutil

        shutil.rmtree(self.temp_dir)

    def test_finds_violation_in_nested_file(self) -> None:
        nested_dir = Path(self.temp_dir) / "src"
        nested_dir.mkdir()
        test_file = nested_dir / "test.py"
        test_file.write_text("# ChatGPT code\n", encoding="utf-8")

        violations = walk_directory(Path(self.temp_dir), self.config)
        self.assertEqual(len(violations), 1)
        self.assertEqual(violations[0].file_path, "src/test.py")

    def test_ignores_excluded_directories(self) -> None:
        ignored_dir = Path(self.temp_dir) / "node_modules"
        ignored_dir.mkdir()
        test_file = ignored_dir / "test.py"
        test_file.write_text("# ChatGPT code\n", encoding="utf-8")

        violations = walk_directory(Path(self.temp_dir), self.config)
        self.assertEqual(len(violations), 0)

    def test_skips_symlinks(self) -> None:
        real_dir = Path(self.temp_dir) / "real"
        real_dir.mkdir()
        test_file = real_dir / "test.py"
        test_file.write_text("# ChatGPT code\n", encoding="utf-8")

        link_dir = Path(self.temp_dir) / "link"
        link_dir.symlink_to(real_dir)

        violations = walk_directory(Path(self.temp_dir), self.config)
        self.assertEqual(len(violations), 1)

    def test_respects_extension_filter(self) -> None:
        test_py = Path(self.temp_dir) / "test.py"
        test_py.write_text("# ChatGPT code\n", encoding="utf-8")

        test_txt = Path(self.temp_dir) / "test.txt"
        test_txt.write_text("# ChatGPT code\n", encoding="utf-8")

        violations = walk_directory(Path(self.temp_dir), self.config)
        self.assertEqual(len(violations), 1)


class TestFormatViolation(unittest.TestCase):
    """Tests for violation formatting."""

    def test_format_contains_all_fields(self) -> None:
        violation = Violation(
            file_path="src/test.py",
            line_number=42,
            match_text="ChatGPT",
            rule_description="Test rule",
        )
        formatted = format_violation(violation)

        self.assertIn("src/test.py", formatted)
        self.assertIn("42", formatted)
        self.assertIn("ChatGPT", formatted)
        self.assertIn("Test rule", formatted)
        self.assertIn("PROTOCOL ZERO VIOLATION", formatted)


class TestLoadConfig(unittest.TestCase):
    """Tests for configuration loading."""

    def test_loads_valid_config(self) -> None:
        with tempfile.NamedTemporaryFile(
            mode="w",
            suffix=".yaml",
            delete=False,
            encoding="utf-8",
        ) as f:
            f.write(
                """
denylist:
  - pattern: "\\\\btest\\\\b"
    description: "Test pattern"
extensions_to_scan:
  - .py
ignore_dirs:
  - node_modules
"""
            )
            temp_path = Path(f.name)

        try:
            config = load_config(temp_path)
            self.assertEqual(len(config.denylist), 1)
            self.assertIn(".py", config.extensions_to_scan)
            self.assertIn("node_modules", config.ignore_dirs)
        finally:
            temp_path.unlink()

    def test_missing_config_exits(self) -> None:
        with self.assertRaises(SystemExit):
            load_config(Path("/nonexistent/config.yaml"))


class TestPositiveControl(unittest.TestCase):
    """Integration tests using positive control fixture."""

    def test_positive_control_has_violations(self) -> None:
        fixture_path = Path(__file__).parent / "fixtures" / "positive_control.py"
        if not fixture_path.exists():
            self.skipTest("Positive control fixture not found")

        rules = [
            DenylistRule(r"\bchatgpt\b", "ChatGPT reference"),
            DenylistRule(r"\bclaude\b", "Claude reference"),
            DenylistRule(r"\bgpt-4\b", "GPT-4 reference"),
            DenylistRule(r"\bai\s+assisted\b", "AI assisted reference"),
            DenylistRule(r"\bopenai\b", "OpenAI reference"),
            DenylistRule(r"\bcopilot\b", "Copilot reference"),
            DenylistRule(r"\bllm\s+generated\b", "LLM generated reference"),
            DenylistRule(r"\bgenerated\s+by\s+ai\b", "Generated by AI reference"),
        ]

        violations = scan_file(fixture_path, "positive_control.py", rules)
        self.assertGreater(len(violations), 0)


class TestNegativeControl(unittest.TestCase):
    """Integration tests using negative control fixture."""

    def test_negative_control_no_violations(self) -> None:
        fixture_path = Path(__file__).parent / "fixtures" / "negative_control.py"
        if not fixture_path.exists():
            self.skipTest("Negative control fixture not found")

        rules = [
            DenylistRule(r"\bchatgpt\b", "ChatGPT reference"),
            DenylistRule(r"\bclaude\b", "Claude reference"),
            DenylistRule(r"\bgpt-4\b", "GPT-4 reference"),
            DenylistRule(r"\bai\s+assisted\b", "AI assisted reference"),
            DenylistRule(r"\bopenai\b", "OpenAI reference"),
            DenylistRule(r"\bcopilot\b", "Copilot reference"),
            DenylistRule(r"\bllm\s+generated\b", "LLM generated reference"),
        ]

        violations = scan_file(fixture_path, "negative_control.py", rules)
        self.assertEqual(len(violations), 0)


class TestPerformance(unittest.TestCase):
    """Performance tests to ensure scanner meets requirements."""

    def test_large_file_performance(self) -> None:
        import time

        with tempfile.NamedTemporaryFile(
            mode="w",
            suffix=".py",
            delete=False,
            encoding="utf-8",
        ) as f:
            for i in range(10000):
                f.write(f"# Line {i}: This is a clean line of code\n")
            temp_path = Path(f.name)

        rules = [
            DenylistRule(r"\bchatgpt\b", "ChatGPT reference"),
            DenylistRule(r"\bopenai\b", "OpenAI reference"),
            DenylistRule(r"\bclaude\b", "Claude reference"),
        ]

        try:
            start = time.perf_counter()
            violations = scan_file(temp_path, "test.py", rules)
            elapsed = time.perf_counter() - start

            self.assertEqual(len(violations), 0)
            self.assertLess(elapsed, 1.0)
        finally:
            temp_path.unlink()


if __name__ == "__main__":
    unittest.main()
